# rsass
Утилита для шифрования файлов

[![CodeFactor](https://www.codefactor.io/repository/github/sashashrek/rsass/badge)](https://www.codefactor.io/repository/github/sashashrek/rsass)

---

## Установка
Чтобы установить данную утилиту, необходимо клонировать репозиторий себе локально, а после останется только бинарник из исходников:
* ```go mod init rsass```
* ```go build```

В Linux системах достаточно запустить Makefile.

Или можно скачать версию для [Linux](http://188.227.84.204:121/linux/rsass64.tar.gz) и [Windows](http://188.227.84.204:121/windows/rsass64.zip)

## Использование
Данная утилита является консольной. То есть, чтобы её использовать, необходимо открыть терминал (в Линукс) или cmd (в Windows) и перейти в директорию, где лежит бинарник программы. Утилита имеет 3 флага, комбинируя которые можно создать ключи, зашифровать/расшифровать любые файлы.

* Создать ключи: ```rsass -ak=23,73``` - два простых числа; **ak** - add keys. После данной команды в директории, где лежит бинарник, будет создан файл с открытым ключом. Советую не удалять его, потому что утилита будет брать ключ именно из этого файла.
* Зашифровать файл: ```rsass -crypto=/path/to/file``` - данная команда создаст файл по названию идентичный изначальному, только в конце будет **.cry**.
* Расшифровать файл: ```rsass -crypto=/path/to/file.cry -key=a,b``` - где **a** и **b** это закрытый ключ (даётся при создании ключей).

## Возможные проблемы
* При шифровании выбирай адекватных размеров файл
* Не рекомендуется шифровать бинарники

## Математика
Для создания зашифрованного сообщения необходимо действовать по алгоритму: 
```c = m^e mod n```, где:
* c - зашифрованное сообщение
* m - первоначальное сообщение
* e - открытая экспонента
* n - произведение двух простых чисел **a** и **b**

Чтобы найти **e**, необходимо использовать неравенство: 
```1 < e < Fi(n)```, где **Fi(n)** - функция Леонардо Эйлера, ```Fi(n) = (a - 1) * (b - 1) | n = a * b```. В коде это:
```go
func getE(fi int) int {
	var index int
	count := fi
	for index = 2; index < count; index++ {
		if (index%1 == 0) && (fi%1 == 0) && (fi%index != 0) {
			break
		}
	}
	return index
}
```
Для создания закрытого ключа, необходимо использовать тождество: 
```d * e = 1 (mod Fi(n)) => d = 1 (mod Fi(n)) / e => d = (1 + k * Fi(n)) / e```, где **k** будем искать перебором с условием, что ```e != d```, а ```(d * e) mod Fi(n) = 1```, **d** - секретная экспонента. Код:
```go
func getD(e int, fi int) int {
	var d int
	var k int

	for k = 2; k < fi; k++ {
		d = (1 + fi*k) / e
		if d != e && ((e*d)%fi == 1) {
			break
		}
	}
	return d
}
```
Чтобы расшифровать сообщение, необходимо использовать следующее равенство: 
```m = c^d mod n```.
